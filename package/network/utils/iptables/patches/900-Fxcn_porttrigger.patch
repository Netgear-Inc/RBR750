diff -urN iptables-1.4.21.orig/extensions/libipt_TRIGGER.c iptables-1.4.21/extensions/libipt_TRIGGER.c
--- iptables-1.4.21.orig/extensions/libipt_TRIGGER.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.4.21/extensions/libipt_TRIGGER.c	2017-01-14 15:04:40.000000000 +0800
@@ -0,0 +1,199 @@
+/* Port-triggering target. 
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ */
+
+/* Shared library add-on to iptables to add port-trigger support. */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <xtables.h>
+#include <net/netfilter/nf_nat.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_TRIGGER.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRIGGER v%s options:\n"
+" --trigger-type (dnat|in|out)\n"
+"				Trigger type\n"
+" --trigger-proto proto\n"
+"				Trigger protocol\n"
+" --trigger-match port[-port]\n"
+"				Trigger destination port range\n"
+" --trigger-relate port[-port]\n"
+"				Port range to map related destination port range to.\n\n",
+XTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{.name = "trigger-type", .has_arg = true, .val = '1'},
+	{.name = "trigger-proto", .has_arg = true, .val = '2'},
+	{.name = "trigger-match", .has_arg = true, .val = '3'},
+	{.name = "trigger-relate", .has_arg = true, .val = '4'},
+	XT_GETOPT_TABLEEND,
+};
+
+/* Initialize the target. */
+static void
+init(struct xt_entry_target *t)
+{
+}
+
+/* Parses ports */
+static void
+parse_ports(const char *arg, u_int16_t *ports)
+{
+	const char *dash;
+	int port;
+
+	port = atoi(arg);
+	if (port == 0 || port > 65535)
+		xtables_error(PARAMETER_PROBLEM, "Port range `%s' invalid\n", arg);
+
+	dash = strchr(arg, '-');
+	if (!dash)
+		ports[0] = ports[1] = port;
+	else {
+		int maxport;
+
+		maxport = atoi(dash + 1);
+		if (maxport == 0 || maxport > 65535)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Port range `%s' invalid\n", dash+1);
+		if (maxport < port)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Port range `%s' invalid\n", arg);
+		ports[0] = port;
+		ports[1] = maxport;
+	}
+}
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry,
+      struct xt_entry_target **target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (!strcasecmp(optarg, "dnat"))
+			info->type = IPT_TRIGGER_DNAT;
+		else if (!strcasecmp(optarg, "in"))
+			info->type = IPT_TRIGGER_IN;
+		else if (!strcasecmp(optarg, "out"))
+			info->type = IPT_TRIGGER_OUT;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "unknown type `%s' specified", optarg);
+		return 1;
+
+	case '2':
+		if (!strcasecmp(optarg, "tcp"))
+			info->proto = IPPROTO_TCP;
+		else if (!strcasecmp(optarg, "udp"))
+			info->proto = IPPROTO_UDP;
+		else if (!strcasecmp(optarg, "all"))
+			info->proto = 0;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "unknown protocol `%s' specified", optarg);
+		return 1;
+
+	case '3':
+		parse_ports(optarg, info->ports.mport);
+		return 1;
+
+	case '4':
+		parse_ports(optarg, info->ports.rport);
+		*flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Final check; don't care. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const void *ip,
+      const struct xt_entry_target *target,
+      int numeric)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+
+	printf(" TRIGGER ");
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf("type:dnat ");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf("type:in ");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf("type:out ");
+
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+
+	printf("match:%hu", info->ports.mport[0]);
+	if (info->ports.mport[1] > info->ports.mport[0])
+		printf("-%hu", info->ports.mport[1]);
+	printf(" ");
+
+	printf("relate:%hu", info->ports.rport[0]);
+	if (info->ports.rport[1] > info->ports.rport[0])
+		printf("-%hu", info->ports.rport[1]);
+	printf(" ");
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const void *ip, const struct xt_entry_target *target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+
+	printf("--trigger-proto ");
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+	printf("--trigger-match %hu-%hu ", info->ports.mport[0], info->ports.mport[1]);
+	printf("--trigger-relate %hu-%hu ", info->ports.rport[0], info->ports.rport[1]);
+}
+
+static struct xtables_target trigger = {
+	.family		= NFPROTO_IPV4,
+	.name		= "TRIGGER",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct ipt_trigger_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct ipt_trigger_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
+};
+
+void _init(void)
+{
+	xtables_register_target(&trigger);
+}
\ No newline at end of file
diff -urN iptables-1.4.21.orig/include/linux/netfilter_ipv4/ipt_TRIGGER.h iptables-1.4.21/include/linux/netfilter_ipv4/ipt_TRIGGER.h
--- iptables-1.4.21.orig/include/linux/netfilter_ipv4/ipt_TRIGGER.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.4.21/include/linux/netfilter_ipv4/ipt_TRIGGER.h	2017-01-14 15:04:34.000000000 +0800
@@ -0,0 +1,24 @@
+#ifndef _IPT_TRIGGER_H_target
+#define _IPT_TRIGGER_H_target
+
+#define TRIGGER_TIMEOUT 600	/* 600 secs */
+
+enum ipt_trigger_type
+{
+	IPT_TRIGGER_DNAT = 1,
+	IPT_TRIGGER_IN = 2,
+	IPT_TRIGGER_OUT = 3
+};
+
+struct ipt_trigger_ports {
+	u_int16_t mport[2];	/* Related destination port range */
+	u_int16_t rport[2];	/* Port range to map related destination port range to */
+};
+
+struct ipt_trigger_info {
+	enum ipt_trigger_type type;
+	u_int16_t proto;	/* Related protocol */
+	struct ipt_trigger_ports ports;
+};
+
+#endif /*_IPT_TRIGGER_H_target*/
\ No newline at end of file
diff -urN iptables-1.4.21.orig/include/net/netfilter/nf_conntrack_tuple.h iptables-1.4.21/include/net/netfilter/nf_conntrack_tuple.h
--- iptables-1.4.21.orig/include/net/netfilter/nf_conntrack_tuple.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.4.21/include/net/netfilter/nf_conntrack_tuple.h	2017-01-14 15:04:34.000000000 +0800
@@ -0,0 +1,116 @@
+/* This file was manually copied from the Linux kernel source
+ * and manually stripped from __KERNEL__ sections and unused functions.
+ */
+
+/*
+ * Definitions and Declarations for tuple.
+ *
+ * 16 Dec 2003: Yasuyuki Kozakai @USAGI <yasuyuki.kozakai@toshiba.co.jp>
+ *	- generalize L3 protocol dependent part.
+ *
+ * Derived from include/linux/netfiter_ipv4/ip_conntrack_tuple.h
+ */
+
+#ifndef _NF_CONNTRACK_TUPLE_H
+#define _NF_CONNTRACK_TUPLE_H
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+
+/* A `tuple' is a structure containing the information to uniquely
+  identify a connection.  ie. if two packets have the same tuple, they
+  are in the same connection; if not, they are not.
+
+  We divide the structure along "manipulatable" and
+  "non-manipulatable" lines, for the benefit of the NAT code.
+*/
+
+#define NF_CT_TUPLE_L3SIZE	ARRAY_SIZE(((union nf_inet_addr *)NULL)->all)
+
+/* The protocol-specific manipulable parts of the tuple: always in
+   network order! */
+#if 0
+union nf_conntrack_man_proto
+{
+	/* Add other protocols here. */
+	__be16 all;
+
+	struct {
+		__be16 port;
+	} tcp;
+	struct {
+		__be16 port;
+	} udp;
+	struct {
+		__be16 id;
+	} icmp;
+	struct {
+		__be16 port;
+	} dccp;
+	struct {
+		__be16 port;
+	} sctp;
+	struct {
+		__be16 key;	/* GRE key is 32bit, PPtP only uses 16bit */
+	} gre;
+};
+#endif
+
+/* The manipulable part of the tuple. */
+struct nf_conntrack_man
+{
+	union nf_inet_addr u3;
+	union nf_conntrack_man_proto u;
+	/* Layer 3 protocol */
+	u_int16_t l3num;
+};
+
+/* This contains the information to distinguish a connection. */
+struct nf_conntrack_tuple
+{
+	struct nf_conntrack_man src;
+
+	/* These are the parts of the tuple which are fixed. */
+	struct {
+		union nf_inet_addr u3;
+		union {
+			/* Add other protocols here. */
+			__be16 all;
+
+			struct {
+				__be16 port;
+			} tcp;
+			struct {
+				__be16 port;
+			} udp;
+			struct {
+				u_int8_t type, code;
+			} icmp;
+			struct {
+				__be16 port;
+			} dccp;
+			struct {
+				__be16 port;
+			} sctp;
+			struct {
+				__be16 key;
+			} gre;
+		} u;
+
+		/* The protocol. */
+		u_int8_t protonum;
+
+		/* The direction (for tuplehash) */
+		u_int8_t dir;
+	} dst;
+};
+
+struct nf_conntrack_tuple_mask
+{
+	struct {
+		union nf_inet_addr u3;
+		union nf_conntrack_man_proto u;
+	} src;
+};
+
+#endif /* _NF_CONNTRACK_TUPLE_H */
diff -urN iptables-1.4.21.orig/include/net/netfilter/nf_nat.h iptables-1.4.21/include/net/netfilter/nf_nat.h
--- iptables-1.4.21.orig/include/net/netfilter/nf_nat.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.4.21/include/net/netfilter/nf_nat.h	2017-01-14 15:04:34.000000000 +0800
@@ -0,0 +1,55 @@
+#ifndef _NF_NAT_H
+#define _NF_NAT_H
+#include <linux/netfilter_ipv4.h>
+#include <net/netfilter/nf_conntrack_tuple.h>
+
+#define NF_NAT_MAPPING_TYPE_MAX_NAMELEN 16
+
+enum nf_nat_manip_type
+{
+	IP_NAT_MANIP_SRC,
+	IP_NAT_MANIP_DST
+};
+
+/* SRC manip occurs POST_ROUTING or LOCAL_IN */
+#define HOOK2MANIP(hooknum) ((hooknum) != NF_INET_POST_ROUTING && \
+			     (hooknum) != NF_INET_LOCAL_IN)
+
+#define IP_NAT_RANGE_MAP_IPS 1
+#define IP_NAT_RANGE_PROTO_SPECIFIED 2
+#define IP_NAT_RANGE_PROTO_RANDOM 4
+#define IP_NAT_RANGE_PERSISTENT 8
+
+/* NAT sequence number modifications */
+struct nf_nat_seq {
+	/* position of the last TCP sequence number modification (if any) */
+	u_int32_t correction_pos;
+
+	/* sequence number offset before and after last modification */
+	int16_t offset_before, offset_after;
+};
+
+/* Single range specification. */
+struct nf_nat_range
+{
+	/* Set to OR of flags above. */
+	unsigned int flags;
+
+	/* Inclusive: network order. */
+	__be32 min_ip, max_ip;
+
+	/* Inclusive: network order */
+	union nf_conntrack_man_proto min, max;
+};
+
+/* For backwards compat: don't use in modern code. */
+struct nf_nat_multi_range_compat
+{
+	unsigned int rangesize; /* Must be 1. */
+
+	/* hangs off end. */
+	struct nf_nat_range range[1];
+};
+
+#define nf_nat_multi_range nf_nat_multi_range_compat
+#endif
